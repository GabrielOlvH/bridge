# Codebase Report: Terminal Session Architecture & Communication
Generated: 2026-01-17

## Summary

This is a React Native (Expo) mobile app for managing tmux sessions across remote hosts. The app communicates with a Node.js agent running on each host via REST API and WebSocket connections. The terminal UI embeds xterm.js in a WebView and uses bidirectional message passing for input/output.

## Project Structure

```
ter/
├── agent/                 # Node.js backend agent (runs on remote hosts)
│   ├── server.ts         # Hono REST API + WebSocket server
│   ├── pty.ts            # node-pty wrapper
│   ├── tmux.ts           # tmux command helpers
│   ├── sessions.ts       # Session management
│   └── agents.ts         # Session insights (git, agent detection)
├── app/                  # React Native app (Expo Router)
│   ├── session/[hostId]/[name]/
│   │   └── terminal.tsx  # Terminal screen with xterm.js WebView
│   ├── hosts/            # Host management screens
│   └── _layout.tsx       # Navigation structure
├── lib/                  # Shared utilities
│   ├── api.ts            # REST API client functions
│   ├── types.ts          # TypeScript types
│   └── store.tsx         # Zustand state management
└── components/           # Reusable UI components
    ├── SessionCard.tsx
    └── LaunchSheet.tsx
```

## Questions Answered

### Q1: How do terminal sessions work?

**Session Management Flow:**

1. **Session Creation** (`lib/api.ts:67-72`):
   - App calls `createSession(host, name)` → `POST /sessions`
   - Agent runs: `tmux new-session -d -s <name>`
   - Session starts detached in background

2. **Session Listing** (`lib/api.ts:50-61`):
   - App calls `getSessions(host)` → `GET /sessions`
   - Agent runs: `tmux list-sessions -F <format>`
   - Returns array of `Session` objects with metadata

3. **Session Lifecycle**:
   - Create: `POST /sessions` (agent: `tmux new-session`)
   - Rename: `POST /sessions/:name/rename` (agent: `tmux rename-session`)
   - Kill: `POST /sessions/:name/kill` (agent: `tmux kill-session`)

**Entry Points:**
- Agent: `/home/gabrielolv/Documents/Projects/ter/agent/server.ts:461-686` (`startServer()`)
- App: `/home/gabrielolv/Documents/Projects/ter/app/session/[hostId]/[name]/terminal.tsx:248`

### Q2: How does the app communicate with terminals?

**Communication Protocol: REST + WebSocket**

#### REST API (Control Plane)
Location: `agent/server.ts:336-456`

| Endpoint | Method | Purpose | Agent Action |
|----------|--------|---------|--------------|
| `/sessions` | GET | List sessions | `tmux list-sessions` |
| `/sessions` | POST | Create session | `tmux new-session -d` |
| `/sessions/:name/keys` | POST | Send text/keys | `tmux send-keys` |
| `/sessions/:name/resize` | POST | Resize terminal | `tmux resize-window` |
| `/sessions/:name/capture` | GET | Capture pane | `tmux capture-pane` |
| `/sessions/:name/kill` | POST | Kill session | `tmux kill-session` |

**Client Functions** (`lib/api.ts`):
- `createSession()` - Create new tmux session
- `sendText()` - Send text to session (via send-keys)
- `sendKeys()` - Send key sequences
- `captureSession()` - Get terminal output snapshot
- `resizeSession()` - Resize terminal window

#### WebSocket (Data Plane)
Location: `agent/server.ts:503-566`

**Connection:**
- URL: `ws://<host>:4020/ws?session=<name>&cols=80&rows=24&token=<optional>`
- Built by: `app/session/[hostId]/[name]/terminal.tsx:85-94` (`buildWsUrl()`)

**Protocol:**

Client → Server:
```json
{ "type": "input", "data": "command\n" }
{ "type": "resize", "cols": 120, "rows": 40 }
```

Server → Client:
- Raw terminal data (ANSI escape sequences)

**Backend Implementation** (`agent/server.ts:513-566`):
```typescript
// Agent spawns PTY attached to tmux session
const term = pty.spawn('tmux', [
  'new-session', '-A', '-s', session,
  '-x', String(cols), '-y', String(rows)
], { name: 'xterm-256color', ... });

// Bidirectional pipe
term.onData(data => ws.send(data));     // PTY → WebSocket
ws.on('message', msg => {
  const payload = parseClientPayload(msg);
  if (payload.type === 'input') term.write(payload.data);
  if (payload.type === 'resize') term.resize(payload.cols, payload.rows);
});
```

### Q3: What are the existing input mechanisms?

**Input Flow Architecture:**

```
User Input (React Native)
    ↓
WebView Bridge (postMessage/injectJavaScript)
    ↓
xterm.js in WebView
    ↓
WebSocket Client (browser)
    ↓
WebSocket Server (agent)
    ↓
node-pty
    ↓
tmux session
```

#### 1. WebView Bridge (`app/session/[hostId]/[name]/terminal.tsx`)

**React Native → WebView** (lines 293-298):
```typescript
const sendToTerminal = useCallback((data: string) => {
  webRefs.current[currentSessionName]?.injectJavaScript(
    `window.__sendToTerminal && window.__sendToTerminal(${JSON.stringify(data)}); true;`
  );
}, [currentSessionName]);
```

**WebView → React Native** (lines 464-473):
```typescript
onMessage={async (event) => {
  const payload = JSON.parse(event.nativeEvent.data);
  if (payload?.type === 'copy' && typeof payload.text === 'string') {
    await Clipboard.setStringAsync(payload.text);
  }
}}
```

#### 2. xterm.js in WebView (`buildTerminalHtml()` - lines 96-246)

**Terminal Input Handler** (lines 157-161):
```javascript
term.onData((data) => {
  if (socket?.readyState === 1) {
    socket.send(JSON.stringify({ type: 'input', data }));
  }
});
```

**Global Bridge Functions** (exposed to React Native):
- `window.__sendToTerminal(data)` - Send text input
- `window.__focusTerminal()` - Focus terminal
- `window.__blurTerminal()` - Blur terminal
- `window.__fitTerminal()` - Fit terminal to screen
- `window.__copySelection()` - Copy selection to clipboard

#### 3. Helper Key Toolbar (lines 482-510)

When keyboard is visible, shows helper keys:
- Escape, Tab, Arrow keys, PageUp/PageDown
- Clipboard paste button
- Done button (close keyboard)

```typescript
const helperKeys = [
  { label: 'Esc', data: '\u001b' },
  { label: 'Tab', data: '\t' },
  { label: 'Up', data: '\u001b[A' },
  // ... etc
];
```

Tapping a key calls `sendToTerminal(item.data)`.

### Q4: The data flow from app to remote hosts

**Complete Data Flow:**

```
┌─────────────────────────────────────────────────────────────┐
│ React Native App (Mobile)                                   │
│                                                              │
│  User Input                                                  │
│      ↓                                                       │
│  sendToTerminal(data)                                        │
│      ↓                                                       │
│  webView.injectJavaScript()                                  │
│      ↓                                                       │
│  ┌────────────────────────────────────────────────────────┐ │
│  │ WebView (xterm.js)                                     │ │
│  │                                                        │ │
│  │  window.__sendToTerminal(data)                         │ │
│  │      ↓                                                 │ │
│  │  socket.send({ type: "input", data })                  │ │
│  │      ↓                                                 │ │
│  │  WebSocket Client (browser)                            │ │
│  └────────────────────────────────────────────────────────┘ │
│      ↓                                                       │
└──────┼───────────────────────────────────────────────────────┘
       │
       │ WebSocket Connection (ws://host:4020/ws)
       │
       ↓
┌─────────────────────────────────────────────────────────────┐
│ Node.js Agent (Remote Host)                                 │
│                                                              │
│  WebSocket Server (ws module)                                │
│      ↓                                                       │
│  parseClientPayload(message)                                 │
│      ↓                                                       │
│  term.write(payload.data)                                    │
│      ↓                                                       │
│  node-pty (pty.spawn)                                        │
│      ↓                                                       │
│  tmux session                                                │
│      ↓                                                       │
│  Shell/Process                                               │
└─────────────────────────────────────────────────────────────┘
```

**Return Flow (Output):**
```
Shell Output → tmux → node-pty → term.onData() → ws.send(data)
    → WebSocket → xterm.js term.write() → Screen
```

**Session State Queries (REST):**
```
App → getSessions() → HTTP GET /sessions
    → Agent: tmux list-sessions → Parse → JSON response
```

## Key Files

| File | Purpose | Entry Points |
|------|---------|--------------|
| `agent/server.ts` | HTTP + WebSocket server | `startServer():461`, REST routes:336-456, WS handler:503-566 |
| `agent/pty.ts` | node-pty wrapper | `export { pty }` |
| `agent/tmux.ts` | tmux command helpers | `runTmux()`, `capturePane()`, `sessionTarget()` |
| `lib/api.ts` | REST API client | `createSession()`, `sendText()`, `getSessions()` |
| `app/session/[hostId]/[name]/terminal.tsx` | Terminal UI | Main screen:248, WebView:440-474, Bridge:293-316 |
| `lib/types.ts` | TypeScript types | `Host`, `Session`, `SessionInsights` |
| `components/LaunchSheet.tsx` | Session creation UI | `createSession()`:138, `sendText()`:140 |

## Attachment Logic - Where to Add

To add image attachment support for sending images to terminals, you would need to:

### 1. App Side (React Native)

**Location:** `app/session/[hostId]/[name]/terminal.tsx`

**Add Image Picker:**
```typescript
// Around line 74 (helper keys)
const helperKeys = [
  // ... existing keys
  { label: 'Image', data: '', action: 'pickImage' }, // New
];
```

**Add Image Handler:**
```typescript
// Around line 493 (helper key press handler)
onPress={async () => {
  if (item.action === 'pickImage') {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      base64: true,
    });
    if (result.assets?.[0]?.base64) {
      sendImageToTerminal(result.assets[0].base64);
    }
  } else {
    sendToTerminal(item.data);
  }
}}
```

**Add Image Sender:**
```typescript
// Around line 298 (after sendToTerminal)
const sendImageToTerminal = useCallback((base64: string) => {
  webRefs.current[currentSessionName]?.injectJavaScript(
    `window.__sendImage && window.__sendImage(${JSON.stringify(base64)}); true;`
  );
}, [currentSessionName]);
```

### 2. WebView Side (xterm.js)

**Location:** `app/session/[hostId]/[name]/terminal.tsx` (buildTerminalHtml function)

**Add to bridge functions** (around line 168):
```javascript
window.__sendImage = (base64) => {
  if (socket?.readyState === 1) {
    socket.send(JSON.stringify({
      type: 'image',
      data: base64,
      format: 'base64'
    }));
  }
};
```

### 3. Agent Side (WebSocket Handler)

**Location:** `agent/server.ts:531-546`

**Extend payload parser** (line 68):
```typescript
type TmuxImagePayload = {
  type: 'image';
  data: string;
  format: 'base64';
};

type TmuxClientPayload = TmuxInputPayload | TmuxResizePayload | TmuxImagePayload;
```

**Handle image in message handler** (line 531):
```typescript
function handleMessage(data: RawData) {
  const text = data.toString();
  const payload = parseClientPayload(text);
  
  if (payload?.type === 'input') {
    if (termClosed) return;
    term.write(payload.data);
    return;
  }
  
  if (payload?.type === 'image') {
    // Process image - could:
    // 1. Save to temp file and send path
    // 2. Convert to iTerm2 inline image protocol
    // 3. Send as sixel graphics
    handleImageAttachment(payload.data);
    return;
  }
  
  // ... rest of handler
}

function handleImageAttachment(base64: string) {
  // Option 1: iTerm2 inline image protocol
  const imgProto = `\x1b]1337;File=inline=1:${base64}\x07`;
  term.write(imgProto);
  
  // Option 2: Save to file and echo path
  // const tmpPath = saveBase64ToFile(base64);
  // term.write(`Image saved to: ${tmpPath}\n`);
  
  // Option 3: Sixel graphics (if terminal supports)
  // const sixel = convertToSixel(base64);
  // term.write(sixel);
}
```

## Communication Protocol Details

### WebSocket Message Format

**Client → Server:**
```typescript
{ type: 'input', data: string }       // Text input
{ type: 'resize', cols: number, rows: number }  // Terminal resize
{ type: 'image', data: string, format: 'base64' }  // (NEW) Image attachment
```

**Server → Client:**
- Raw binary/text data (ANSI escape sequences)
- No JSON wrapper - direct terminal output

### REST API Authentication

If `TMUX_AGENT_TOKEN` is set:
- Header: `Authorization: Bearer <token>`
- WebSocket: `?token=<token>` query param

**Implementation:** `lib/api.ts:24-26`, `agent/server.ts:475-482`

## Architecture Patterns

### Session Management
- **Backend:** tmux sessions persist after WebSocket disconnect
- **Reconnection:** `tmux new-session -A -s <name>` (attach if exists, create if not)
- **Status:** Polling via `GET /sessions` with optional preview/insights

### Terminal Rendering
- **Framework:** xterm.js 5.5.0 (embedded in WebView)
- **Addons:** FitAddon (auto-resize)
- **Scrolling:** Custom touch gesture → sends mouse events to tmux

### State Management
- **Global:** Zustand store (`lib/store.tsx`) for hosts
- **Sessions:** TanStack Query for caching/refetching
- **Local:** React hooks for terminal state

## Dependencies

**Agent:**
- `hono` - Web framework
- `ws` - WebSocket server
- `node-pty` - Pseudoterminal spawning
- Communicates with system `tmux` binary

**App:**
- `expo-router` - File-based routing
- `react-native-webview` - WebView for xterm.js
- `@tanstack/react-query` - Data fetching
- `expo-haptics`, `expo-clipboard` - Native features

## Open Questions

1. **Image Protocol:** Which terminal image protocol to use?
   - iTerm2 inline images (most compatible with modern terminals)
   - Sixel graphics (older, wider support)
   - Kitty graphics protocol (best quality, limited support)

2. **File Size Limits:** Should images be size-limited or compressed before sending?

3. **Storage:** Should images be saved to disk on the host, or just displayed inline?

4. **Multiple Sessions:** The app supports swipeable multi-session UI - should image attachments work across all sessions or just the active one?

## Conventions Discovered

### Naming
- Files: `kebab-case.tsx` or `PascalCase.tsx` (components)
- Functions: `camelCase` 
- Types: `PascalCase`
- Constants: `SCREAMING_SNAKE_CASE`

### Code Organization
- Agent: Modular by feature (docker.ts, git.ts, ports.ts, etc.)
- App: File-based routing (Expo Router conventions)
- Shared types in `lib/types.ts`

### Error Handling
- Agent: Try/catch → JSON error response `{ error: message }`
- App: TanStack Query error states + toast notifications

### Testing
- No test files found in project
- No test framework configured
