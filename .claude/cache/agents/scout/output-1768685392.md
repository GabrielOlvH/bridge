# Codebase Report: CodexBar GitHub Copilot Implementation
Generated: 2026-01-17 18:28:00

## Summary

CodexBar implements GitHub Copilot usage tracking through a clean OAuth device flow authentication and direct API integration. The implementation uses GitHub's device code flow for authentication (no browser cookies) and queries the internal Copilot API for usage metrics. The architecture is well-separated with Core logic in CodexBarCore and UI in CodexBar.

## Project Structure

```
/tmp/CodexBar/
├── Sources/
│   ├── CodexBarCore/              # Business logic & API clients
│   │   ├── Providers/
│   │   │   └── Copilot/
│   │   │       ├── CopilotDeviceFlow.swift         # OAuth device flow
│   │   │       ├── CopilotUsageFetcher.swift       # API client
│   │   │       └── CopilotProviderDescriptor.swift # Provider config
│   │   ├── CopilotUsageModels.swift                # Data models
│   │   └── UsageFetcher.swift                      # Shared usage models
│   └── CodexBar/                  # UI & coordination
│       ├── Providers/Copilot/
│       │   ├── CopilotLoginFlow.swift              # UI flow
│       │   └── CopilotProviderImplementation.swift # Settings UI
│       └── CopilotTokenStore.swift                 # Keychain storage
```

## Questions Answered

### Q1: How is GitHub Copilot authentication implemented?

**Pattern:** GitHub OAuth Device Flow (RFC 8628)

**Location:** `/tmp/CodexBar/Sources/CodexBarCore/Providers/Copilot/CopilotDeviceFlow.swift`

**Flow:**

1. **Device Code Request**
   - Endpoint: `POST https://github.com/login/device/code`
   - Client ID: `Iv1.b507a08c87ecfe98` (VS Code's client ID)
   - Scope: `read:user`
   - Response: `DeviceCodeResponse` with user code and verification URI

2. **User Verification**
   - User visits `https://github.com/login/device` 
   - Enters device code shown in alert
   - Approves access in browser

3. **Token Polling**
   - Endpoint: `POST https://github.com/login/oauth/access_token`
   - Polls every `interval` seconds (from device code response)
   - Handles errors:
     - `authorization_pending` → continue polling
     - `slow_down` → add 5s delay
     - `expired_token` → timeout error
   - Returns OAuth access token on success

**Entry Point:** `CopilotDeviceFlow.requestDeviceCode() -> DeviceCodeResponse`

**Dependencies:** Foundation/URLSession only (cross-platform)

### Q2: Where are tokens stored?

**Location:** `/tmp/CodexBar/Sources/CodexBar/CopilotTokenStore.swift`

**Storage:** macOS Keychain via `Security` framework

**Keychain Details:**
- Service: `com.steipete.CodexBar`
- Account: `copilot-api-token`
- Class: Generic Password (`kSecClassGenericPassword`)
- Accessibility: `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly`

**Interface:**
```swift
protocol CopilotTokenStoring: Sendable {
    func loadToken() throws -> String?
    func storeToken(_ token: String?) throws
}
```

**Implementation:** `KeychainCopilotTokenStore`

**Key Features:**
- Respects `KeychainAccessGate.isDisabled` for testing
- Triggers keychain prompt handler before access
- Handles token deletion when storing `nil`
- Proper error handling via `CopilotTokenStoreError`

### Q3: How does it fetch usage data from GitHub?

**Location:** `/tmp/CodexBar/Sources/CodexBarCore/Providers/Copilot/CopilotUsageFetcher.swift`

**API Endpoint:**
```
GET https://api.github.com/copilot_internal/user
```

**Headers (mimics VS Code Copilot Chat):**
```swift
Authorization: token <github_oauth_token>
Accept: application/json
Editor-Version: vscode/1.96.2
Editor-Plugin-Version: copilot-chat/0.26.7
User-Agent: GitHubCopilotChat/0.26.7
X-Github-Api-Version: 2025-04-01
```

**Response Model:**
```swift
struct CopilotUsageResponse {
    let quotaSnapshots: QuotaSnapshots
    let copilotPlan: String          // e.g., "individual", "business"
    let assignedDate: String
    let quotaResetDate: String
    
    struct QuotaSnapshots {
        let premiumInteractions: QuotaSnapshot?  // Primary usage
        let chat: QuotaSnapshot?                 // Secondary usage
    }
    
    struct QuotaSnapshot {
        let entitlement: Double
        let remaining: Double
        let percentRemaining: Double  // 0-100
        let quotaId: String
    }
}
```

**Mapping to Usage Display:**
- Primary window: `premiumInteractions.percentRemaining` → convert to used percent
- Secondary window: `chat.percentRemaining` → convert to used percent
- Plan label: `copilotPlan` (capitalized)
- Reset dates: NOT provided by API (unlike other providers)

### Q4: What is the UI flow for authentication?

**Location:** `/tmp/CodexBar/Sources/CodexBar/Providers/Copilot/CopilotLoginFlow.swift`

**Flow Steps:**

1. **Request Device Code**
   ```swift
   let code = try await CopilotDeviceFlow().requestDeviceCode()
   ```

2. **Show Alert with Code**
   - Copy user code to clipboard automatically
   - Display verification URI
   - Buttons: "Open Browser" / "Cancel"

3. **Open Browser**
   - Opens `https://github.com/login/device` in default browser
   - User enters code from clipboard

4. **Background Polling**
   - Spawns detached task to poll for token
   - Shows modal "Waiting for Authentication..." alert
   - User can cancel to abort flow

5. **Save Token on Success**
   ```swift
   settings.copilotAPIToken = token
   settings.setProviderEnabled(provider: .copilot, enabled: true)
   ```

6. **Display Result**
   - Success alert or error alert
   - Handles cancellation gracefully

**Key Design Pattern:**
- Uses floating invisible host window when no main window exists
- Async/await with structured concurrency
- Task cancellation support throughout

### Q5: How is this integrated into the provider system?

**Location:** `/tmp/CodexBar/Sources/CodexBar/Providers/Copilot/CopilotProviderImplementation.swift`

**Registration:** Uses `@ProviderImplementationRegistration` macro

**Settings UI:**
- Field ID: `copilot-api-token`
- Type: Secure field (password-style)
- Actions:
  - "Sign in with GitHub" (visible when token empty)
  - "Sign in again" (link style, visible when token exists)
- Both actions call `CopilotLoginFlow.run(settings:)`

**Provider Descriptor:**
- ID: `.copilot`
- Display Name: "Copilot"
- Session Label: "Premium" (for premium interactions)
- Weekly Label: "Chat" (for chat quota)
- Default Enabled: `false`
- Dashboard URL: `https://github.com/settings/copilot`
- Status Page: `https://www.githubstatus.com/`

**Fetch Strategy:**
- Type: API Token (`ProviderFetchKind.apiToken`)
- Source Modes: `.auto`, `.cli`
- Availability Check: `ProviderTokenResolver.copilotToken(environment:)`
- No fallback strategies (only one data source)

## Data Models

### Core Usage Model

**Location:** `/tmp/CodexBar/Sources/CodexBarCore/UsageFetcher.swift`

```swift
struct UsageSnapshot: Codable, Sendable {
    let primary: RateWindow?      // Session/5-hour window
    let secondary: RateWindow?    // Weekly window
    let tertiary: RateWindow?     // Optional third window
    let providerCost: ProviderCostSnapshot?
    let updatedAt: Date
    let identity: ProviderIdentitySnapshot?
}

struct RateWindow: Codable, Equatable, Sendable {
    let usedPercent: Double       // 0-100
    let windowMinutes: Int?       // e.g., 300 for 5hr, 10080 for week
    let resetsAt: Date?           // When window resets
    let resetDescription: String? // Human-readable "in X hours"
}

struct ProviderIdentitySnapshot: Codable, Sendable {
    let providerID: UsageProvider?
    let accountEmail: String?
    let accountOrganization: String?
    let loginMethod: String?      // Plan type for Copilot
}
```

### Copilot-Specific Models

**Location:** `/tmp/CodexBar/Sources/CodexBarCore/CopilotUsageModels.swift`

```swift
struct CopilotUsageResponse: Decodable {
    let quotaSnapshots: QuotaSnapshots
    let copilotPlan: String
    let assignedDate: String
    let quotaResetDate: String
    
    struct QuotaSnapshots {
        let premiumInteractions: QuotaSnapshot?
        let chat: QuotaSnapshot?
    }
    
    struct QuotaSnapshot {
        let entitlement: Double
        let remaining: Double
        let percentRemaining: Double
        let quotaId: String
    }
}
```

## Key Files Reference

| File | Purpose | Key Exports |
|------|---------|------------|
| `CopilotDeviceFlow.swift` | OAuth device flow client | `requestDeviceCode()`, `pollForToken()` |
| `CopilotUsageFetcher.swift` | Copilot API client | `fetch() -> UsageSnapshot` |
| `CopilotUsageModels.swift` | API response models | `CopilotUsageResponse` |
| `CopilotLoginFlow.swift` | UI authentication flow | `run(settings:)` |
| `CopilotTokenStore.swift` | Keychain token storage | `CopilotTokenStoring` protocol |
| `CopilotProviderImplementation.swift` | Settings UI | `settingsFields()`, `runLoginFlow()` |
| `CopilotProviderDescriptor.swift` | Provider metadata | `makeDescriptor()` |
| `UsageFetcher.swift` | Shared usage models | `UsageSnapshot`, `RateWindow` |

## Architecture Patterns

### Authentication Flow

```
[User Clicks "Sign In"]
        ↓
[CopilotLoginFlow.run()]
        ↓
[CopilotDeviceFlow.requestDeviceCode()]
        ↓
[Show Alert + Copy Code]
        ↓
[Open Browser] ←→ [User Enters Code on GitHub]
        ↓
[CopilotDeviceFlow.pollForToken()]  (background task)
        ↓
[KeychainCopilotTokenStore.storeToken()]
        ↓
[Enable Provider + Show Success]
```

### Usage Fetch Flow

```
[Refresh Trigger]
        ↓
[CopilotProviderDescriptor.fetchPlan]
        ↓
[CopilotAPIFetchStrategy.fetch()]
        ↓
[ProviderTokenResolver.copilotToken()]  (from environment/keychain)
        ↓
[CopilotUsageFetcher.fetch()]
        ↓
[GET api.github.com/copilot_internal/user]
        ↓
[Parse CopilotUsageResponse]
        ↓
[Map to UsageSnapshot]
        ↓
[Update UI]
```

### Separation of Concerns

| Layer | Module | Responsibilities |
|-------|--------|-----------------|
| **UI** | CodexBar | Alerts, windows, user interaction, settings UI |
| **Core Logic** | CodexBarCore | API clients, OAuth flows, data models |
| **Storage** | CodexBar | Keychain access (platform-specific) |
| **Coordination** | CodexBar | Settings store, provider registry |

## API Integration Patterns

### 1. Device Flow Pattern (OAuth 2.0 RFC 8628)

**Used by:** GitHub Copilot, potentially JetBrains

**Benefits:**
- No browser cookies needed
- Works without embedded browser
- User-friendly (clipboard + browser)
- Secure (token never touches clipboard)

**Implementation:**
```swift
// Request device code
let code = try await deviceFlow.requestDeviceCode()

// User authorizes in browser
NSWorkspace.shared.open(URL(string: code.verificationUri))

// Poll for token (with exponential backoff on "slow_down")
let token = try await deviceFlow.pollForToken(
    deviceCode: code.deviceCode, 
    interval: code.interval
)
```

### 2. API Token Pattern

**Used by:** Copilot (after auth), z.ai, Kimi K2

**Benefits:**
- Simple REST API calls
- Easy to test
- No session management

**Implementation:**
```swift
var request = URLRequest(url: apiURL)
request.setValue("token \(token)", forHTTPHeaderField: "Authorization")
request.setValue("application/json", forHTTPHeaderField: "Accept")

let (data, response) = try await URLSession.shared.data(for: request)
let usage = try JSONDecoder().decode(CopilotUsageResponse.self, from: data)
```

### 3. User-Agent Spoofing

**Purpose:** Access internal/beta APIs by mimicking official clients

**Headers:**
```swift
Editor-Version: vscode/1.96.2
Editor-Plugin-Version: copilot-chat/0.26.7
User-Agent: GitHubCopilotChat/0.26.7
X-Github-Api-Version: 2025-04-01
```

**Note:** These headers make GitHub's internal API accept the request as if from VS Code.

## Conventions Discovered

### Naming

**Files:** PascalCase with descriptor suffix
- `CopilotDeviceFlow.swift`
- `CopilotUsageFetcher.swift`
- `CopilotProviderDescriptor.swift`

**Protocols:** Adjective + "ing" suffix
- `CopilotTokenStoring`
- `Sendable` (standard)

**Enums:** PascalCase descriptor pattern
- `CopilotProviderDescriptor`
- `UsageProvider`

**Functions:** camelCase, descriptive
- `requestDeviceCode()`
- `pollForToken(deviceCode:interval:)`
- `fetch() -> UsageSnapshot`

### Code Organization

**Provider Pattern:**
```
Providers/<ProviderName>/
├── <Provider>DeviceFlow.swift        # Auth (if OAuth)
├── <Provider>UsageFetcher.swift      # API client
├── <Provider>ProviderDescriptor.swift # Metadata
└── <Provider>LoginFlow.swift         # UI flow (in CodexBar/)
```

**Model Separation:**
- API response models: `<Provider>UsageResponse`
- Internal models: `UsageSnapshot`, `RateWindow`
- Mapping happens in fetcher

### Error Handling

**Pattern:** Throw descriptive errors, handle at UI boundary

```swift
// In Core: Throw URLError
throw URLError(.userAuthenticationRequired)

// In UI: Catch and display
catch {
    let alert = NSAlert()
    alert.messageText = "Login Failed"
    alert.informativeText = error.localizedDescription
    alert.runModal()
}
```

### Swift Concurrency

**Patterns:**
- `async/await` for all network calls
- `Task.detached` for background operations
- `Task.checkCancellation()` in polling loops
- `@MainActor` for UI code
- `Sendable` protocol everywhere

### Macros

**Provider Registration:**
```swift
@ProviderDescriptorRegistration
@ProviderDescriptorDefinition
enum CopilotProviderDescriptor { ... }

@ProviderImplementationRegistration
struct CopilotProviderImplementation { ... }
```

**Purpose:** Auto-register providers in global registry

## Security Considerations

### Token Storage

- Uses macOS Keychain (encrypted, backed by user's login password)
- Accessibility: After first unlock only (not available when device locked)
- Service/account naming prevents conflicts
- Proper cleanup on logout (delete keychain item)

### Network Security

- HTTPS only (GitHub APIs)
- OAuth tokens never logged or stored in plaintext
- Token passed in `Authorization` header (not URL params)
- No token caching in memory (refetched from keychain each time)

### Privacy

- Only requests `read:user` scope (minimal access)
- Uses VS Code's public OAuth client ID (Iv1.b507a08c87ecfe98)
- No telemetry or tracking visible in code
- All data stays local except for API calls

## Comparison with Other Providers

| Provider | Auth Method | API Type | Storage |
|----------|-------------|----------|---------|
| **Copilot** | OAuth Device Flow | REST API | Keychain |
| Claude | Browser Cookies + OAuth | GraphQL | Cookies + Keychain |
| Codex | CLI RPC + Cookies | RPC + Web | Cookies + auth.json |
| Cursor | Browser Cookies | Web Scraping | Cookies |
| Gemini | OAuth (gcloud) | REST API | gcloud config |
| z.ai | Manual API Token | REST API | Keychain |

**Copilot Advantages:**
- No browser cookies needed
- Clean OAuth flow
- Official-ish API (internal but stable)
- Cross-platform compatible

**Copilot Limitations:**
- No reset date provided by API
- Internal API could break
- Requires GitHub account

## Testing & Development

### Mock Token for Testing

```swift
// Disable keychain in tests
KeychainAccessGate.isDisabled = true

// Use environment variable
settings.copilotAPIToken = ProcessInfo.processInfo.environment["COPILOT_TEST_TOKEN"]
```

### Debug Endpoints

The descriptor provides:
- Dashboard: `https://github.com/settings/copilot`
- Status Page: `https://www.githubstatus.com/`

### Error Scenarios

1. **No token** → `URLError.userAuthenticationRequired`
2. **Expired token** → 401/403 → prompt re-login
3. **Network error** → Throw URLError, display in UI
4. **Cancelled flow** → Catch `CancellationError`, silent dismiss

## Open Questions

### API Stability

- Is `https://api.github.com/copilot_internal/user` a stable endpoint?
- The `/copilot_internal/` path suggests it's internal/private
- Could break with GitHub API updates

### Reset Dates

- Why doesn't the API provide `resetsAt` dates?
- `quotaResetDate` is in the response but not per-quota
- Could potentially use `quotaResetDate` for both windows

### Rate Limiting

- No rate limit handling visible in code
- Should add `Retry-After` header support
- GitHub API typically has 5000 req/hr limit for OAuth

### Multi-Account Support

- Current implementation: one token per app
- Could support multiple GitHub accounts?
- Keychain account could be `copilot-api-token-<username>`

## Recommendations

### For Similar Implementations

1. **Use Device Flow for Desktop Apps**
   - Better UX than embedded browsers
   - More secure than browser cookie extraction
   - Works with 2FA/SSO

2. **Separate Core from UI**
   - Makes testing easier
   - Enables CLI tool reuse
   - Platform-agnostic core logic

3. **Use Keychain for Tokens**
   - Never store tokens in plain text files
   - macOS Keychain is standard, well-tested
   - Provides access control prompts

4. **Spoof User-Agent When Needed**
   - Many internal APIs check User-Agent
   - Mimicking official clients often required
   - Document which headers are necessary

5. **Handle Cancellation Properly**
   - Long-running polls should check `Task.checkCancellation()`
   - Clean up resources in `defer` blocks
   - Show cancellation option in UI

### Potential Improvements

1. **Add Retry Logic**
   ```swift
   func fetchWithRetry(maxRetries: Int = 3) async throws -> UsageSnapshot {
       for attempt in 1...maxRetries {
           do {
               return try await fetch()
           } catch where attempt < maxRetries {
               try await Task.sleep(nanoseconds: UInt64(attempt) * 1_000_000_000)
               continue
           }
       }
   }
   ```

2. **Cache Tokens in Memory**
   ```swift
   private var cachedToken: String?
   private var cacheExpiry: Date?
   ```

3. **Add Token Validation**
   ```swift
   func validateToken(_ token: String) async -> Bool {
       // Make test API call to check if token is still valid
   }
   ```

4. **Parse Reset Date**
   ```swift
   // Use quotaResetDate from response
   let formatter = ISO8601DateFormatter()
   let resetsAt = formatter.date(from: usage.quotaResetDate)
   ```

## Conclusion

The CodexBar Copilot implementation is a clean, well-architected example of OAuth device flow + REST API integration. Key strengths:

- Proper separation of concerns (Core vs UI)
- Modern Swift concurrency patterns
- Secure token storage
- User-friendly authentication flow
- Comprehensive error handling

The code is production-ready and serves as a good reference for implementing similar provider integrations.
