# Codebase Report: Session State Polling and Update Logic
Generated: 2026-01-17 10:45:00

## Summary
The app uses TanStack Query (React Query) for polling session data with insights. Polling occurs at the home page and session detail page, with different intervals and purposes. State comparison logic uses `lastPolled` timestamps to determine which insights are most recent.

## Project Structure
```
app/
  index.tsx                          # Home page - polls all sessions with insights
  session/
    [hostId]/[name]/
      index.tsx                      # Session detail - polls single session
      terminal.tsx                   # Terminal view - polls sessions list only
lib/
  api.ts                             # API functions (getSessions, getSessionInsights, getUsage)
  types.ts                           # Type definitions (SessionInsights, InsightsMeta)
```

## Questions Answered

### Q1: Where does the app poll for session data?

**Location 1:** `app/index.tsx` (Home Page)
- **Lines:** 39-67
- **Polling Target:** All sessions across all hosts with insights
- **Interval:** 15 seconds (`refetchInterval: 15_000`)
- **Query Key:** `['home-sessions', hosts.map((h) => h.id).join(',')]`

```typescript
const { data: queryData, refetch: refetchSessions, isPending } = useQuery({
  queryKey: ['home-sessions', hosts.map((h) => h.id).join(',')],
  queryFn: async () => {
    const statusMap: Record<string, HostStatus> = {};
    const onlineHosts: Host[] = [];

    const results = await Promise.all(
      hosts.map(async (host): Promise<SessionWithHost[]> => {
        try {
          const hostSessions = await getSessions(host, { 
            preview: true, 
            previewLines: 6, 
            insights: true  // ← Fetches session insights
          });
          statusMap[host.id] = 'online';
          onlineHosts.push(host);
          return hostSessions.map((s) => ({ ...s, host, hostStatus: 'online' }));
        } catch {
          statusMap[host.id] = 'offline';
          return [];
        }
      })
    );
    // ...
  },
  enabled: ready && hosts.length > 0,
  staleTime: 15_000,
  refetchInterval: 15_000,
});
```

**Location 2:** `app/session/[hostId]/[name]/index.tsx` (Session Detail)
- **Lines:** 31-44
- **Polling Target:** Single session by name
- **Interval:** 20 seconds (`refetchInterval: 20_000`)
- **Query Key:** `['session', params.hostId, sessionName]`

```typescript
const { data: session, isError, isFetching } = useQuery({
  queryKey: ['session', params.hostId, sessionName],
  queryFn: async () => {
    if (!host) return null;
    const sessions = await getSessions(host);
    const current = sessions.find((item) => item.name === sessionName) ?? null;
    updateHostLastSeen(host.id, Date.now());
    return current;
  },
  enabled: !!host,
  staleTime: 30_000,
  refetchInterval: 20_000,  // ← Polls every 20 seconds
});
```

**Location 3:** `app/session/[hostId]/[name]/terminal.tsx` (Terminal View)
- **Lines:** 204-210
- **Polling Target:** Sessions list (for sidebar navigation)
- **Interval:** None - uses `staleTime: 60_000` only
- **Query Key:** `['sessions', params.hostId]`

```typescript
const { data: sessions = [] } = useQuery({
  queryKey: ['sessions', params.hostId],
  queryFn: async () => (host ? getSessions(host) : []),
  enabled: !!host,
  staleTime: 60_000,  // ← No polling, just cache for 60s
});
```

### Q2: How are session insights fetched?

**API Function:** `lib/api.ts` - `getSessions()`
- **Lines:** 105-117
- **Supports Options:**
  - `preview`: Include terminal preview lines
  - `previewLines`: Number of preview lines
  - `insights`: Include session insights (agent state, usage, etc.)

```typescript
export async function getSessions(
  host: Host,
  options?: { preview?: boolean; previewLines?: number; insights?: boolean }
): Promise<Session[]> {
  const params = new URLSearchParams();
  if (options?.preview) params.set('preview', '1');
  if (options?.previewLines) params.set('lines', String(options.previewLines));
  if (options?.insights) params.set('insights', '1');  // ← Triggers insights fetch
  const query = params.toString();
  const timeoutMs = options?.insights ? 12000 : DEFAULT_TIMEOUT_MS;
  return request(host, `/sessions${query ? `?${query}` : ''}`, { method: 'GET' }, timeoutMs);
}
```

**Separate Usage Endpoint:** `lib/api.ts` - `getUsage()`
- **Lines:** 119-121
- **Purpose:** Fetch usage insights without session data
- **Used by:** Home page parallel query

```typescript
export async function getUsage(host: Host): Promise<SessionInsights> {
  return request(host, '/usage', { method: 'GET' }, 12000);
}
```

### Q3: What is the SessionInsights structure?

**Type Definition:** `lib/types.ts`
- **Lines:** 81-96

```typescript
export type SessionInsights = {
  codex?: ProviderUsage;
  claude?: ProviderUsage;
  copilot?: ProviderUsage;
  cursor?: ProviderUsage;
  git?: GitStatus;
  meta?: InsightsMeta;
};

export type InsightsMeta = {
  lastPolled?: number;       // ← Timestamp of last successful poll
  lastAttempt?: number;
  refreshing?: boolean;
  error?: string;
  activeAgent?: 'codex' | 'claude' | null;
  agentState?: 'running' | 'idle' | 'stopped';  // ← Key state indicator
  agentCommand?: string | null;
};
```

### Q4: How does state comparison work?

**Location:** `app/index.tsx` - `usageCards` memo
- **Lines:** 137-151
- **Logic:** Use `lastPolled` timestamp to pick the most recent insights per host

```typescript
const usageCards = useMemo(() => {
  const byHost = new Map<string, { host: Host; insights: SessionInsights; lastPolled: number }>();
  
  // Process session insights
  sessions.forEach((session) => {
    if (!session.insights) return;
    const lastPolled = session.insights.meta?.lastPolled ?? 0;
    const existing = byHost.get(session.host.id);
    if (!existing || lastPolled >= existing.lastPolled) {  // ← Compare timestamps
      byHost.set(session.host.id, { host: session.host, insights: session.insights, lastPolled });
    }
  });

  // Process usage data (separate endpoint)
  usageData?.forEach((entry) => {
    const lastPolled = entry.usage?.meta?.lastPolled ?? 0;
    const existing = byHost.get(entry.hostId);
    if (!existing || lastPolled >= existing.lastPolled) {  // ← Same comparison logic
      byHost.set(entry.hostId, { host: entry.host, insights: entry.usage ?? {}, lastPolled });
    }
  });
  
  // ... build usage cards from merged insights
}, [sessions, usageData]);
```

### Q5: How is agentState used in the UI?

**Location:** `app/index.tsx` - Session card rendering
- **Lines:** 371-373
- **Purpose:** Display agent state badge on session cards

```typescript
const agentState = session.insights?.meta?.agentState ?? 'stopped';
const stateLabel = agentState === 'running' ? 'Running' : agentState === 'idle' ? 'Idle' : 'Stopped';
const stateTone = agentState === 'running' ? 'accent' : agentState === 'idle' ? 'clay' : 'muted';
```

**Visual Mapping:**
| agentState | Label | Color Tone | Meaning |
|------------|-------|------------|---------|
| `running` | Running | accent | Agent actively processing |
| `idle` | Idle | clay | Agent ready but not working |
| `stopped` | Stopped | muted | No agent active |

### Q6: Are there existing hooks or effects that respond to state changes?

**Finding:** NO automatic response to insights changes detected.

**Evidence:**
- `terminal.tsx` has useEffect hooks (lines 225, 304) but they handle:
  - Keyboard show/hide events
  - Session switching logic
- No useEffect hooks depend on `session.insights` or `agentState`
- No comparison of previous vs current insights state
- UI updates are purely reactive to TanStack Query data changes

**Implication:** To add state-change notifications, you would need to:
1. Add a useEffect that watches `session.insights?.meta?.agentState`
2. Compare previous state using useRef
3. Trigger notifications/haptics on state transitions

## Polling Intervals Summary

| Screen | Query | Interval | Stale Time | Purpose |
|--------|-------|----------|------------|---------|
| Home | `home-sessions` | 15s | 15s | Monitor all sessions + insights |
| Home | `home-usage` | 15s | 15s | Fetch usage data separately |
| Session Detail | `session` | 20s | 30s | Track single session status |
| Terminal | `sessions` | None | 60s | Session list for navigation only |

## State Update Flow

```
[15s Poll] → getSessions(insights: true)
    ↓
[Server] Returns Session[] with insights.meta.agentState
    ↓
[TanStack Query] Updates cache → triggers re-render
    ↓
[useMemo] Processes insights, compares lastPolled
    ↓
[UI] Renders agentState badge with current state
```

**No intermediate state comparison** - UI shows whatever the latest poll returns.

## Key Files

| File | Purpose | Entry Points |
|------|---------|--------------|
| `app/index.tsx` | Home screen with session polling | `useQuery` lines 39, 74 |
| `app/session/[hostId]/[name]/index.tsx` | Session detail with polling | `useQuery` line 31 |
| `app/session/[hostId]/[name]/terminal.tsx` | Terminal view (no insights) | `useQuery` line 204 |
| `lib/api.ts` | API layer | `getSessions()`, `getUsage()` |
| `lib/types.ts` | Type definitions | `SessionInsights`, `InsightsMeta` |

## Recommendations for State-Change Hooks

To add notifications when `agentState` changes from 'idle' → 'running':

1. **In terminal.tsx or index.tsx**, add:
```typescript
const prevAgentState = useRef<string | undefined>();

useEffect(() => {
  const currentState = session?.insights?.meta?.agentState;
  
  if (prevAgentState.current && currentState && prevAgentState.current !== currentState) {
    // State changed!
    if (prevAgentState.current === 'idle' && currentState === 'running') {
      // Trigger notification: agent started working
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
    }
  }
  
  prevAgentState.current = currentState;
}, [session?.insights?.meta?.agentState]);
```

2. **Consider using TanStack Query's `onSuccess` callback** instead of useEffect:
```typescript
const { data: session } = useQuery({
  // ... existing config
  onSuccess: (newData) => {
    if (previousData && newData) {
      const prevState = previousData.insights?.meta?.agentState;
      const newState = newData.insights?.meta?.agentState;
      if (prevState !== newState) {
        // Handle state transition
      }
    }
  }
});
```

## Open Questions
- Should notifications be opt-in or always-on?
- Which state transitions should trigger notifications? (idle→running, running→stopped, etc.)
- Should haptic feedback differ based on transition type?
- Is 15-20s polling granularity sufficient for responsive notifications?
