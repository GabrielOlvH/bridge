# Codebase Report: Terminal and Process Control Implementation
Generated: 2026-01-17

## Summary

This codebase implements two types of terminal views for a React Native/Expo mobile app that manages tmux sessions and Docker containers. Both terminals use WebView + xterm.js with WebSocket connections to remote agents. The kill/stop functionality currently exists as a **Ctrl+C button** (OctagonX icon) that sends interrupt signals, NOT a full process termination button.

## Project Structure

```
app/
  session/[hostId]/[name]/
    terminal.tsx                    # Tmux session terminal (swipeable multi-session)
  hosts/[id]/docker/[containerId]/
    terminal.tsx                    # Docker container terminal (single session)
agent/
  server.ts                         # Backend WebSocket server
  pty-runner.ts                     # PTY process spawner
components/
  PortRow.tsx                       # Example kill button UI (for port processes)
lib/
  api.ts                            # API client functions
```

## Questions Answered

### Q1: Where are the terminal components implemented?

**Primary Files:**
1. `/home/gabrielolv/Documents/Projects/ter/app/session/[hostId]/[name]/terminal.tsx`
   - **Purpose:** Full-featured tmux session terminal
   - **Features:** Horizontal swipe navigation, multi-session support, keyboard helpers
   - **Lines:** 271-600+

2. `/home/gabrielolv/Documents/Projects/ter/app/hosts/[id]/docker/[containerId]/terminal.tsx`
   - **Purpose:** Docker container exec terminal
   - **Features:** Simpler single-session terminal for container shells
   - **Lines:** 187-313

**Common Pattern:**
Both use the same architecture:
```typescript
// Build WebSocket URL
function buildWsUrl(host, sessionName): string {
  const protocol = host.baseUrl.includes('https') ? 'wss:' : 'ws:';
  return `${protocol}://${host}/ws?session=${sessionName}&token=${token}`;
}

// Embed xterm.js via WebView
function buildTerminalHtml(wsUrl): string {
  return `<!doctype html>...
    <script src="xterm.js"></script>
    <script>
      const term = new Terminal({ ... });
      const socket = new WebSocket('${wsUrl}');
      socket.onmessage = (e) => term.write(e.data);
      term.onData((data) => socket.send(JSON.stringify({ type: 'input', data })));
    </script>
  `;
}
```

### Q2: What kill/stop button functionality exists?

**Current Implementation:** Ctrl+C Signal (NOT full process kill)

| Terminal Type | Button | Icon | Action | Code Location |
|--------------|--------|------|--------|---------------|
| **Session Terminal** | Ctrl+C | `<OctagonX color="#F85149"/>` | Sends `\u0003` (Ctrl+C) | Line 449-453 |
| **Docker Terminal** | Ctrl+C | `<OctagonX color="#F85149"/>` | Sends `\u0003` via `__sendCtrlC()` | Line 230-237 |

**Session Terminal Implementation:**
```typescript
// app/session/[hostId]/[name]/terminal.tsx:446-453
<Pressable
  style={({ pressed }) => [styles.headerButton, pressed && styles.headerButtonPressed]}
  onPress={() => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    sendToTerminal('\u0003'); // Ctrl+C character
  }}
>
  <OctagonX size={16} color="#F85149" />
</Pressable>
```

**Docker Terminal Implementation:**
```typescript
// app/hosts/[id]/docker/[containerId]/terminal.tsx:230-237
<Pressable
  onPress={() => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    webRef.current?.injectJavaScript('window.__sendCtrlC && window.__sendCtrlC(); true;');
  }}
>
  <OctagonX size={16} color="#F85149" />
</Pressable>

// In HTML template (line 89-91):
window.__sendCtrlC = () => {
  if (socket?.readyState === 1) socket.send(JSON.stringify({ type: 'input', data: '\u0003' }));
};
```

**Key Difference:**
- **Ctrl+C sends SIGINT** - Interrupts foreground process but doesn't kill the terminal session/container
- **NOT a kill button** - Doesn't terminate the underlying PTY or tmux session

### Q3: How are processes managed and terminated?

**Process Lifecycle:**

```
[React Native UI]
      |
      | WebSocket (/ws or /docker/exec)
      v
[agent/server.ts] - WebSocket handlers
      |
      | pty.spawn()
      v
[PTY Process] - tmux attach OR docker exec
      |
      | term.onData / term.write
      v
[Actual Process] - running in tmux session or container
```

**Backend Process Management:**

Location: `/home/gabrielolv/Documents/Projects/ter/agent/server.ts`

**Tmux Session WebSocket (lines 685-739):**
```typescript
termWss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
  const sessionName = url.searchParams.get('session');
  
  // Spawn PTY attached to tmux session
  const term = pty.spawn('tmux', ['attach', '-t', sessionName], {
    cols, rows,
    env: { TERM: 'xterm-256color' }
  });
  
  let termClosed = false;
  
  // Bidirectional data flow
  term.onData((data) => {
    if (ws.readyState === WebSocket.OPEN) ws.send(data);
  });
  
  ws.on('message', (data) => {
    const payload = parseClientPayload(text);
    if (payload?.type === 'input') term.write(payload.data); // Ctrl+C goes here
    if (payload?.type === 'resize') term.resize(payload.cols, payload.rows);
  });
  
  // Cleanup on exit or disconnect
  const cleanup = () => {
    termClosed = true;
    try { term.kill(); } catch {} // Kill PTY process (tmux attach)
  };
  
  ws.on('close', cleanup);
  ws.on('error', cleanup);
});
```

**Docker Exec WebSocket (lines 741-804):**
```typescript
dockerWss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
  const container = url.searchParams.get('container');
  
  // Spawn PTY for docker exec
  const term = pty.spawn('docker', ['exec', '-it', container, shell], {
    cols, rows,
    env: { TERM: 'xterm-256color' }
  });
  
  // Same pattern as tmux
  const cleanup = () => {
    termClosed = true;
    try { term.kill(); } catch {} // Kill PTY (docker exec process)
  };
  
  ws.on('close', cleanup);
});
```

**Process Termination Behavior:**

| Event | Action | Effect |
|-------|--------|--------|
| User presses OctagonX (Ctrl+C) | Sends `\u0003` to PTY | **SIGINT to foreground process** |
| WebSocket closes | Calls `term.kill()` | **Kills PTY wrapper** (tmux attach or docker exec) |
| PTY exits | `term.onExit()` callback | Closes WebSocket |
| User navigates away | React Native closes WebSocket | Triggers cleanup → kills PTY |

**IMPORTANT:** 
- Ctrl+C button does NOT kill the tmux session - only interrupts the running command
- Closing the WebSocket (navigating away) kills the PTY but **tmux session persists**
- To kill a session, use the API endpoint: `POST /sessions/:name/kill`

### Q4: How does WebSocket communication work?

**Client → Server Protocol:**

```typescript
// From xterm.js in WebView
socket.send(JSON.stringify({
  type: 'input',
  data: '\u0003'  // User input (Ctrl+C, typed chars, etc.)
}));

socket.send(JSON.stringify({
  type: 'resize',
  cols: 80,
  rows: 24
}));
```

**Server → Client Protocol:**

```typescript
// From PTY to WebSocket (raw terminal data)
ws.send(data); // ANSI escape sequences, text output
```

**Exposed JavaScript Functions:**

Both terminals inject functions into the WebView for React Native to call:

| Function | Purpose | Used By |
|----------|---------|---------|
| `window.__sendToTerminal(data)` | Send input to terminal | Paste button, helper keys |
| `window.__sendCtrlC()` | Send Ctrl+C | Docker terminal kill button |
| `window.__focusTerminal()` | Focus xterm.js | Session switching |
| `window.__blurTerminal()` | Blur xterm.js | Hide keyboard |
| `window.__fitTerminal()` | Resize to fit | onLoadEnd, orientation change |
| `window.__copySelection()` | Copy selection or viewport | Copy button |

**Example Usage:**
```typescript
// React Native side
webRef.current?.injectJavaScript('window.__sendCtrlC && window.__sendCtrlC(); true;');

// WebView side (in HTML template)
window.__sendCtrlC = () => {
  if (socket?.readyState === 1) {
    socket.send(JSON.stringify({ type: 'input', data: '\u0003' }));
  }
};
```

## Architecture Map

```
┌─────────────────────────────────────────────────────────────┐
│ React Native App (Expo)                                     │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ Terminal Screen (WebView)                            │  │
│  │                                                        │  │
│  │  Header: [←] [Copy] [Ctrl+C OctagonX]                │  │
│  │                                                        │  │
│  │  ┌──────────────────────────────────────────────┐    │  │
│  │  │ xterm.js (HTML in WebView)                   │    │  │
│  │  │                                                │    │  │
│  │  │  Terminal { cursorBlink, theme }             │    │  │
│  │  │     ↕ WebSocket                               │    │  │
│  │  └──────────────────────────────────────────────┘    │  │
│  │                                                        │  │
│  │  Helper Keys: [Tab] [Esc] [↑] [↓] [PgUp] [PgDn]      │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
└──────────────────────────────┬───────────────────────────────┘
                               │
                               │ WebSocket (wss:// or ws://)
                               │
┌──────────────────────────────▼───────────────────────────────┐
│ Agent Server (Node.js + Hono)                                │
│                                                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │ WebSocket Server (ws library)                           │ │
│  │                                                          │ │
│  │  termWss (/ws) ─────────┐                               │ │
│  │                          │                               │ │
│  │  dockerWss (/docker/exec)│                               │ │
│  │                          │                               │ │
│  └──────────────────────────┼──────────────────────────────┘ │
│                             │                                │
│  ┌──────────────────────────▼──────────────────────────────┐ │
│  │ PTY Process (node-pty)                                  │ │
│  │                                                          │ │
│  │  pty.spawn('tmux', ['attach', '-t', session])           │ │
│  │     OR                                                   │ │
│  │  pty.spawn('docker', ['exec', '-it', container, 'sh'])  │ │
│  │                                                          │ │
│  │  term.onData((data) => ws.send(data))                   │ │
│  │  ws.on('message', (data) => term.write(data))           │ │
│  │  ws.on('close', () => term.kill())                      │ │
│  └──────────────────────────┬──────────────────────────────┘ │
└─────────────────────────────┼────────────────────────────────┘
                              │
                              │ stdin/stdout/stderr
                              │
┌─────────────────────────────▼────────────────────────────────┐
│ Actual Process                                                │
│                                                               │
│  • tmux session (persists after disconnect)                  │
│    OR                                                         │
│  • Docker container shell (exits when WebSocket closes)      │
└───────────────────────────────────────────────────────────────┘
```

**Process Control Flow:**

```
User Action          →  WebSocket Message  →  PTY Action        →  Effect
───────────────────────────────────────────────────────────────────────────
Tap Ctrl+C button    →  { type: 'input',   →  term.write('\u0003') → SIGINT to process
                         data: '\u0003' }

Type in terminal     →  { type: 'input',   →  term.write(data)  → Input to process
                         data: "ls\n" }

Close app/navigate   →  WebSocket close    →  term.kill()       → Kill PTY wrapper
                                                                    (session persists)

Session process exit →  term.onExit()      →  ws.close()        → Close WebSocket
```

## Key Files

| File | Purpose | Key Entry Points | Lines |
|------|---------|------------------|-------|
| `app/session/[hostId]/[name]/terminal.tsx` | Tmux session terminal UI | `SessionTerminalScreen()`, `buildWsUrl()`, `buildTerminalHtml()` | 271-600+ |
| `app/hosts/[id]/docker/[containerId]/terminal.tsx` | Docker container terminal UI | `DockerTerminalScreen()`, `buildDockerWsUrl()` | 187-313 |
| `agent/server.ts` | WebSocket server + PTY management | `termWss.on('connection')` (line 685), `dockerWss.on('connection')` (line 741) | 685-804 |
| `agent/pty-runner.ts` | PTY process spawner (unused in current impl) | `spawn()` | 45 |
| `lib/api.ts` | API client for REST endpoints | `killSession()` (line 81), `killPorts()` (line 157) | Full file |

## Conventions Discovered

### Naming
- **Files:** kebab-case with brackets for params (`[hostId]/[name]/terminal.tsx`)
- **Components:** PascalCase (`SessionTerminalScreen`)
- **Functions:** camelCase (`buildWsUrl`, `sendToTerminal`)
- **Constants:** camelCase (`helperKeys`, `termWss`)

### UI Patterns
- **Header buttons:** Floating rounded header with `OctagonX` for destructive actions
- **Colors:** 
  - Background: `#0B0D0F` (dark terminal)
  - Text: `#E6EDF3` (light)
  - Destructive: `#F85149` (red for Ctrl+C)
  - Pressed: `#1E2226` (darker highlight)
- **Haptics:** 
  - Light: Copy/paste actions
  - Medium: Ctrl+C, session navigation
  - Success: Clipboard notifications

### WebSocket Pattern
```typescript
// 1. Build URL with auth
const wsUrl = buildWsUrl(host, sessionName);

// 2. Embed in HTML template
const html = buildTerminalHtml(wsUrl);

// 3. Render in WebView
<WebView source={{ html }} ref={webRef} />

// 4. Inject JavaScript for actions
webRef.current?.injectJavaScript('window.__sendCtrlC(); true;');
```

### Process Control
- **Ctrl+C:** Always `\u0003` character sent via WebSocket
- **Kill PTY:** `term.kill()` in cleanup handler
- **Kill Session:** `POST /sessions/:name/kill` API (not UI button)
- **Kill Port Process:** Separate UI (PortRow component) with kill button

## Reference Implementation: PortRow Kill Button

Location: `/home/gabrielolv/Documents/Projects/ter/components/PortRow.tsx`

**This shows a REAL kill button** (not Ctrl+C):
```typescript
// lines 48-52
<Pressable style={styles.killButton} onPress={onKill}>
  <AppText variant="label" style={styles.killText}>
    ✕
  </AppText>
</Pressable>

// Styling
killButton: {
  backgroundColor: '#F85149',
  paddingHorizontal: 8,
  paddingVertical: 4,
  borderRadius: 4,
}
```

**Backend Kill Implementation:**
```typescript
// agent/ports.ts:200-226
export async function killProcesses(pids: number[]): Promise<{
  killed: number[];
  failed: { pid: number; error: string }[];
}> {
  const killed: number[] = [];
  const failed: { pid: number; error: string }[] = [];
  
  for (const pid of pids) {
    try {
      // Use kill command with SIGTERM (graceful)
      await execFileAsync('kill', ['-15', String(pid)], { timeout: 5000 });
      killed.push(pid);
    } catch (err) {
      failed.push({ pid, error: err instanceof Error ? err.message : String(err) });
    }
  }
  
  return { killed, failed };
}
```

## Missing: Process Kill Button in Terminal

**Current State:**
- OctagonX button sends Ctrl+C (SIGINT) - interrupts foreground process
- NO button to kill the underlying tmux session or docker exec process
- WebSocket disconnect kills PTY but tmux session persists

**To Add a Real Kill Button:**

1. **For tmux sessions:**
   - Call API: `POST /sessions/:name/kill` (already exists)
   - This runs: `tmux kill-session -t <name>`
   - See: `agent/server.ts:413-420`

2. **For docker containers:**
   - Currently: Only Ctrl+C (SIGINT)
   - Could add: Send SIGTERM/SIGKILL via PTY
   - Or: Close WebSocket + kill PTY (already happens on navigate)

**Example Implementation (tmux session):**
```typescript
// Add to terminal header
<Pressable
  onPress={async () => {
    Alert.alert(
      'Kill Session',
      'Terminate tmux session completely?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Kill',
          style: 'destructive',
          onPress: async () => {
            await killSession(host, currentSessionName);
            router.back();
          }
        }
      ]
    );
  }}
>
  <Trash2 size={16} color="#F85149" />
</Pressable>
```

## Open Questions

1. **Should terminals have a kill session button?**
   - Current: Only Ctrl+C (SIGINT)
   - Alternative: Add full session termination (confirm dialog)

2. **What happens to tmux sessions on WebSocket disconnect?**
   - PTY process (tmux attach) is killed
   - Tmux session itself persists (by design)
   - User can reconnect later

3. **Should docker exec have a kill button?**
   - Current: Only Ctrl+C
   - When WebSocket closes, PTY is killed (container shell exits)
   - Probably don't need separate kill button

4. **How to distinguish Ctrl+C vs Kill buttons in UI?**
   - Ctrl+C: OctagonX (already implemented)
   - Kill process: Trash2 or Skull icon?
   - Kill session: Requires confirmation dialog

## Related Files for Context

| File | Relevance |
|------|-----------|
| `lib/api.ts:81-85` | `killSession()` API client |
| `agent/server.ts:413-420` | `POST /sessions/:name/kill` endpoint |
| `agent/ports.ts:200-226` | `killProcesses()` - SIGTERM implementation |
| `components/PortRow.tsx:48-52` | Kill button UI reference |
| `app/ports/index.tsx:58-75` | Port kill mutation (TanStack Query) |

## Summary for Implementation

**To implement a terminal kill button:**

1. **Decide scope:**
   - Kill foreground process only? (Already exists: Ctrl+C)
   - Kill entire session? (Use `killSession()` API)
   - Kill PTY wrapper? (Already happens on WebSocket close)

2. **UI Pattern:**
   - Add new button to header (next to OctagonX)
   - Use different icon (Trash2, Skull, XCircle)
   - Require confirmation dialog for destructive action
   - Show haptic feedback (Medium/Heavy impact)

3. **Backend:**
   - For tmux: Use existing `POST /sessions/:name/kill`
   - For docker: Either send SIGTERM to PTY or just close WebSocket

4. **Error Handling:**
   - Show Alert on failure
   - Navigate back on success
   - Invalidate TanStack Query cache for sessions list

**Code Locations:**
- Terminal UI: `app/session/[hostId]/[name]/terminal.tsx:428-455`
- Kill API: `lib/api.ts:81-85`
- Backend: `agent/server.ts:413-420`
- Reference: `components/PortRow.tsx` (kill button example)
